# PE file information

## Object file vs Executable file

Object File vs Executable File

| Feature          | Object File (.o)                         | Executable File (a.out, hello)          |
| :--------------- | :--------------------------------------- | :-------------------------------------- |
| Purpose          | Intermediate compilation unit            | Final program ready to run              |
| Generated by     | Compiler (gcc -c file.c)                 | Linker (gcc file.o or ld)               |
| Contains         | Machine code + placeholders              | Machine code with real addresses        |
| e_type (ELF)     | ET_REL (relocatable)                     | ET_EXEC (executable) or ET_DYN (shared) |
| Has entry point? | âŒ No (e_entry = 0)                      | âœ… Yes (e_entry â‰  0)                   |
| Executable?      | âŒ No                                    | âœ… Yes                                 |
| Sections         | .text, .data, .bss, .rel*, symbol tables | .text, .data, .bss, and runtime headers |
| Used by          | Linker                                   | Operating system                        |
|                  |                                          |                                         |

**Analogy**:

Think of building a house:

- ðŸ§± Object file = individual wall panels (compiled code)
- ðŸ› ï¸ Linker = crew that connects the walls, installs wiring (resolves symbols)
- ðŸ  Executable = full house, ready to move in and use
  
## Basic File Information

```bash
file hello.o
```

```output
main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
```

Confirms the file is an ELF relocatable object file.
relocatable object file: Contains machine code and symbols, but not linked to a final executable.

### 3.2 View Symbols (Functions, Variables)

Symbols are functions, variables, and other identifiers in your code.
In the object file, they're stored in a symbol table.
The symbol table is used by the linker to resolve references between files.

```bash
nm hello.o
```

```output
0000000000000000 T greet
0000000000000016 T main
                 U puts
```

Let's Break Down Your Output

| Address          | Type | Symbol | Meaning                                                                                                                                          |
| :--------------- | :--- | :----- | :----------------------------------------------------------------------------------------------------------------------------------------------- |
| 0000000000000000 | T    | greet  | A function called greet, defined in this file, stored in the Text (code) section                                                                 |
| 0000000000000016 | T    | main   | The main() function, also defined in this file, starting at offset 0x16                                                                          |
| (blank)          | U    | puts   | This is a symbol the code uses, but it's Undefined in this file. It will be resolved (linked) later, probably from the standard C library (libc) |
|                  |      |        |                                                                                                                                                  |

What This Tells Us:

- greet() and main() are implemented in your source code, so they show up with type T (Text/code).
- puts() is a library function (from stdio.h), so it's only referenced â€” not defined in your file. The linker will resolve it when creating the final executable.

  - U puts (undefined) â†’ External function not defined in this file.
    - printf is a library function, not defined in this file.
    - puts is a function used by printf.
  - T greet and T main (defined in this file)

Summary Table of Symbol Types (Common)

| Symbol | Meaning                                       |
| :----- | :-------------------------------------------- |
| T      | Text section (function code, defined in file) |
| U      | Undefined (used but not defined in this file) |
| D      | Data section (global variables)               |
| B      | BSS section (uninitialized data)              |
| R      | Read-only data                                |
| W      | Weak symbol                                   |

### 3.3. Hex Dump the Object File

```bash
xxd hello.o
```

```hexdump
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0100 3e00 0100 0000 0000 0000 0000 0000  ..>.............
00000020: 0000 0000 0000 0000 b002 0000 0000 0000  ................
00000030: 0000 0000 4000 0000 0000 4000 0d00 0c00  ....@.....@.....
00000040: 5548 89e5 488d 0500 0000 0048 89c7 e800  UH..H......H....
00000050: 0000 0090 5dc3 5548 89e5 b800 0000 00e8  ....].UH........
00000060: 0000 0000 b800 0000 005d c348 656c 6c6f  .........].Hello
00000070: 2066 726f 6d20 7468 6520 6772 6565 7420   from the greet
00000080: 6675 6e63 7469 6f6e 2100 0047 4343 3a20  function!..GCC:
00000090: 2844 6562 6961 6e20 3134 2e32 2e30 2d31  (Debian 14.2.0-1
000000a0: 3729 2031 342e 322e 3000 1400 0000 0000  7) 14.2.0.......
000000b0: 0000 017a 5200 0178 1001 1b0c 0708 9001  ...zR..x........
000000c0: 0000 1c00 0000 1c00 0000 0000 0000 1600  ................
000000d0: 0000 0041 0e10 8602 430d 0651 0c07 0800  ...A....C..Q....
000000e0: 0000 1c00 0000 3c00 0000 0000 0000 1500  ......<.........
000000f0: 0000 0041 0e10 8602 430d 0650 0c07 0800  ...A....C..P....
00000100: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000110: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000120: 0100 0000 0400 f1ff 0000 0000 0000 0000  ................
00000130: 0000 0000 0000 0000 0000 0000 0300 0100  ................
00000140: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000150: 0000 0000 0300 0500 0000 0000 0000 0000  ................
00000160: 0000 0000 0000 0000 0900 0000 1200 0100  ................
00000170: 0000 0000 0000 0000 1600 0000 0000 0000  ................
00000180: 0f00 0000 1000 0000 0000 0000 0000 0000  ................
00000190: 0000 0000 0000 0000 1400 0000 1200 0100  ................
000001a0: 1600 0000 0000 0000 1500 0000 0000 0000  ................
000001b0: 0068 656c 6c6f 2e63 0067 7265 6574 0070  .hello.c.greet.p
000001c0: 7574 7300 6d61 696e 0000 0000 0000 0000  uts.main........
000001d0: 0700 0000 0000 0000 0200 0000 0300 0000  ................
000001e0: fcff ffff ffff ffff 0f00 0000 0000 0000  ................
000001f0: 0400 0000 0500 0000 fcff ffff ffff ffff  ................
00000200: 2000 0000 0000 0000 0400 0000 0400 0000   ...............
00000210: fcff ffff ffff ffff 2000 0000 0000 0000  ........ .......
00000220: 0200 0000 0200 0000 0000 0000 0000 0000  ................
00000230: 4000 0000 0000 0000 0200 0000 0200 0000  @...............
00000240: 1600 0000 0000 0000 002e 7379 6d74 6162  ..........symtab
00000250: 002e 7374 7274 6162 002e 7368 7374 7274  ..strtab..shstrt
00000260: 6162 002e 7265 6c61 2e74 6578 7400 2e64  ab..rela.text..d
00000270: 6174 6100 2e62 7373 002e 726f 6461 7461  ata..bss..rodata
00000280: 002e 636f 6d6d 656e 7400 2e6e 6f74 652e  ..comment..note.
00000290: 474e 552d 7374 6163 6b00 2e72 656c 612e  GNU-stack..rela.
000002a0: 6568 5f66 7261 6d65 0000 0000 0000 0000  eh_frame........
000002b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000002c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000002d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000002e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000002f0: 2000 0000 0100 0000 0600 0000 0000 0000   ...............
00000300: 0000 0000 0000 0000 4000 0000 0000 0000  ........@.......
00000310: 2b00 0000 0000 0000 0000 0000 0000 0000  +...............
00000320: 0100 0000 0000 0000 0000 0000 0000 0000  ................
00000330: 1b00 0000 0400 0000 4000 0000 0000 0000  ........@.......
00000340: 0000 0000 0000 0000 d001 0000 0000 0000  ................
00000350: 4800 0000 0000 0000 0a00 0000 0100 0000  H...............
00000360: 0800 0000 0000 0000 1800 0000 0000 0000  ................
00000370: 2600 0000 0100 0000 0300 0000 0000 0000  &...............
00000380: 0000 0000 0000 0000 6b00 0000 0000 0000  ........k.......
00000390: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000003a0: 0100 0000 0000 0000 0000 0000 0000 0000  ................
000003b0: 2c00 0000 0800 0000 0300 0000 0000 0000  ,...............
000003c0: 0000 0000 0000 0000 6b00 0000 0000 0000  ........k.......
000003d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000003e0: 0100 0000 0000 0000 0000 0000 0000 0000  ................
000003f0: 3100 0000 0100 0000 0200 0000 0000 0000  1...............
00000400: 0000 0000 0000 0000 6b00 0000 0000 0000  ........k.......
00000410: 1f00 0000 0000 0000 0000 0000 0000 0000  ................
00000420: 0800 0000 0000 0000 0000 0000 0000 0000  ................
00000430: 3900 0000 0100 0000 3000 0000 0000 0000  9.......0.......
00000440: 0000 0000 0000 0000 8a00 0000 0000 0000  ................
00000450: 2000 0000 0000 0000 0000 0000 0000 0000   ...............
00000460: 0100 0000 0000 0000 0100 0000 0000 0000  ................
00000470: 4200 0000 0100 0000 0000 0000 0000 0000  B...............
00000480: 0000 0000 0000 0000 aa00 0000 0000 0000  ................
00000490: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000004a0: 0100 0000 0000 0000 0000 0000 0000 0000  ................
000004b0: 5700 0000 0100 0000 0200 0000 0000 0000  W...............
000004c0: 0000 0000 0000 0000 aa00 0000 0000 0000  ................
000004d0: 5800 0000 0000 0000 0000 0000 0000 0000  X...............
000004e0: 0800 0000 0000 0000 0000 0000 0000 0000  ................
000004f0: 5200 0000 0400 0000 4000 0000 0000 0000  R.......@.......
00000500: 0000 0000 0000 0000 1802 0000 0000 0000  ................
00000510: 3000 0000 0000 0000 0a00 0000 0800 0000  0...............
00000520: 0800 0000 0000 0000 1800 0000 0000 0000  ................
00000530: 0100 0000 0200 0000 0000 0000 0000 0000  ................
00000540: 0000 0000 0000 0000 0801 0000 0000 0000  ................
00000550: a800 0000 0000 0000 0b00 0000 0400 0000  ................
00000560: 0800 0000 0000 0000 1800 0000 0000 0000  ................
00000570: 0900 0000 0300 0000 0000 0000 0000 0000  ................
00000580: 0000 0000 0000 0000 b001 0000 0000 0000  ................
00000590: 1900 0000 0000 0000 0000 0000 0000 0000  ................
000005a0: 0100 0000 0000 0000 0000 0000 0000 0000  ................
000005b0: 1100 0000 0300 0000 0000 0000 0000 0000  ................
000005c0: 0000 0000 0000 0000 4802 0000 0000 0000  ........H.......
000005d0: 6100 0000 0000 0000 0000 0000 0000 0000  a...............
000005e0: 0100 0000 0000 0000 0000 0000 0000 0000  ................
```

#### ðŸ§± 1. ELF Header (64 bytes)

Structure (for ELF64):

| Field       | Offset | Size | Description                                        |
| :---------- | :----- | :--- | :------------------------------------------------- |
| e_ident     | 0x00   | 16   | Magic bytes, class (32/64-bit), endianness, OS ABI |
| e_type      | 0x10   | 2    | Type of file (relocatable, executable, etc.)       |
| e_machine   | 0x12   | 2    | Target architecture (e.g. x86-64)                  |
| e_version   | 0x14   | 4    | ELF version                                        |
| e_entry     | 0x18   | 8    | Entry point (start of execution)                   |
| e_phoff     | 0x20   | 8    | Offset to program header table                     |
| e_shoff     | 0x28   | 8    | Offset to section header table                     |
| e_flags     | 0x30   | 4    | Processor-specific flags                           |
| e_ehsize    | 0x34   | 2    | ELF header size                                    |
| e_phentsize | 0x36   | 2    | Size of one program header entry                   |
| e_phnum     | 0x38   | 2    | Number of program header entries                   |
| e_shentsize | 0x3A   | 2    | Size of one section header entry                   |
| e_shnum     | 0x3C   | 2    | Number of section headers                          |
| e_shstrndx  | 0x3E   | 2    | Index of the section header string table           |
|             |        |      |                                                    |

ðŸ” Use case: This header tells you where the sections are, how many there are, and how to parse them.

```bash
readelf -h ./hello.o
```

```output
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          688 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         13
  Section header string table index: 12
```

```bash
xxd hello.o | head -n 1
```

```bash
00000000  7f 45 4c 46 02 01 01 00  ...   â†’ 0x7F 'E' 'L' 'F' (ELF magic number)
```

- This marks the file as an ELF (Executable and Linkable Format) file.
- Common in Linux for object files, executables, shared libraries.
- 02 = 64-bit
- 01 = little-endian

âœ… This confirms this is a 64-bit ELF object file.

How to read the Number of Sections:

Find the e_shnum field in the ELF header:

| Field   | Offset | Size | Description               |
| :------ | :----- | :--- | ------------------------- |
| e_shnum | 0x3C   | 2    | Number of section headers |

```bash

```bash
xxd -s 0x3C -l 2 -p hello.o
```

```output
0d00
```

Convert from little-endian to big-endian:

```bash
 xxd -s 0x3C -l 2 -p hello.o | xxd | xxd -r 
```

```output
000d
```

-r â†’ Reverse hex dump (converts little-endian to big-endian).

Convert to decimal:

```bash
xxd -s 0x3C -l 2 -p hello.o | xxd -r -p | od -An -t u2
```

```output
13
```

#### 2. Program Header + Section Header Info

ðŸ§© Section Header Entry (ELF64):

Each section header is 64 bytes and contains:

| Field        | Offset | Size | Description                                |
| :----------- | :----- | :--- | :----------------------------------------- |
| sh_name      | 0x00   | 4    | Offset into the section name string table  |
| sh_type      | 0x04   | 4    | Section type (code, data, symbol table...) |
| sh_flags     | 0x08   | 8    | Flags (e.g. executable, writable)          |
| sh_addr      | 0x10   | 8    | Virtual address (runtime location)         |
| sh_offset    | 0x18   | 8    | Offset in file where section starts        |
| sh_size      | 0x20   | 8    | Section size in bytes                      |
| sh_link      | 0x28   | 4    | Section index link (depends on type)       |
| sh_info      | 0x2C   | 4    | Extra info (depends on type)               |
| sh_addralign | 0x30   | 8    | Alignment                                  |
| sh_entsize   | 0x38   | 8    | Entry size (for tables like symtab)        |

```bash
00000010  01 00 3e 00 ...
```

- 3e 00 = x86-64 machine architecture
- Header info points to:
  - .text section (code)
  - .data, .bss
  - .symtab (symbol table)
  - .strtab (string table)

Youâ€™ll see these names later in ASCII (e.g. .symtab, .strtab, .text, .data).

#### 3. Machine Code Instructions

```bash
00000040  55 48 89 e5 48 8d 05 00 00 00 00 48 89 c7 e8 00
00000050  00 00 00 90 5d c3 ...
```

- These are x86-64 instructions.

- For example:
  - 55 â†’ push rbp (save base pointer)
  - 48 89 e5 â†’ mov rbp, rsp (set up stack frame)
  - 5d â†’ pop rbp (restore base pointer)
  - c3 â†’ ret (return from function)

Youâ€™re seeing the compiled machine code for your C functions (main, greet).

âœ… Even though it's binary, this is the actual code the CPU will execute.

#### 4. Embedded Strings

```bash
00000060  ... 48 65 6c 6c 6f 20 66 72 6f 6d 20 74 68 65 ...
```

This is your string literal: "Hello from the greet function!"

#### 5. Symbol Names

Look at the ASCII section near:

```bash
000001b0: 0068 656c 6c6f 2e63 0067 7265 6574 0070  .hello.c.greet.p
000001c0: 7574 7300 6d61 696e 0000 0000 0000 0000  uts.main........
```

These are C identifiers from your code:

- hello.c
- greet
- puts
- main

âœ… These are stored in the symbol string table, used by tools like nm, objdump, and the linker.

#### 6. Section Names

Typical Sections

| Name      | Purpose                          |
| :-------- | :------------------------------- |
| .text     | Contains executable code         |
| .data     | Initialized writable variables   |
| .bss      | Uninitialized variables (zeroed) |
| .rodata   | Read-only data (e.g. strings)    |
| .symtab   | Symbol table (functions, vars)   |
| .strtab   | String table (for symbol names)  |
| .shstrtab | Names of the sections themselves |
|           |                                  |

ðŸ’¡ The .shstrtab section is where section names are stored. Each sh_name in the section header is an offset into this string table.

Toward the end, youâ€™ll see:

```bash
00000240: 1600 0000 0000 0000 002e 7379 6d74 6162  ..........symtab
00000250: 002e 7374 7274 6162 002e 7368 7374 7274  ..strtab..shstrt
00000260: 6162 002e 7265 6c61 2e74 6578 7400 2e64  ab..rela.text..d
00000270: 6174 6100 2e62 7373 002e 726f 6461 7461  ata..bss..rodata
```

These are ELF section names:

| Section Name | Purpose                                     |
| :----------- | :------------------------------------------ |
| .symtab      | Symbol table (function/variable references) |
| .strtab      | String table (names of symbols)             |
| .text        | Code (machine instructions)                 |
| .data        | Initialized variables                       |
| .bss         | Uninitialized variables                     |
| .rodata      | Read-only data (like strings)               |
|              |                                             |

| Element                            | Found in Hex Dump      | Meaning                      |
| :--------------------------------- | :--------------------- | :--------------------------- |
| 7f 45 4c 46                        | Magic bytes            | ELF file                     |
| Code like 55 48 89 e5              | x86-64 instructions    | Translated C code            |
| ASCII text like greet, puts, .text | Symbol & section names | Helps in reverse engineering |
| String like Hello from greet!      | Read-only data         | Found in .rodata section     |

## Tools for inspecting

```bash
readelf -h file      # ELF header
readelf -S file      # Section headers
objdump -h file      # Section headers (alternative)
hexdump -C file      # Raw bytes
```

